\documentclass[11pt]{article}

\usepackage{cite}
\usepackage{graphicx}
\usepackage{hyperref}


\begin{document}

\title{Analysing TLS traffic\\ HW6 - CNS Sapienza}
\author{Davide Spallaccini - 1642557}
\date{1 of December 2017}
\maketitle


\section{Introduction}
In this report we will analyse through a network sniffer the traffic generated by the TLS Handshake Protocol of a client connecting to a well known website commenting the purpose of messages in the sequence they are exchanged. Transport Layer Security (TLS) and its predecessor Secure Sockets Layer (SSL), whose versions v2 and v3 are today considered unsecure, are cryptographic protocols providing communications security over TCP/IP networks (even if it has been adapted to UDP as well \cite{RFC6347}), like the Internet, allowing client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery through authentication, data integrity and encryption mechanisms.

\paragraph*{Background}
TLS lies in between the application and the transport layer. It is designed to work on top of a reliable transport protocol, and is essentially divided in two sublayers: the TCP Record Protocol Layer responsible of fragmentation of messages into manageable bloks, encryption of the hashed data, compression/decompression of outgoing/incoming data, applying MACs and transmitting data across the upper and lower layers; and the higher layer which defines the Alert protocol that notify one of the peers about errors providing different alert levels and descriptions, the Change Cipher Spec protocol defining the re-negotiated cipher specifications and keys that will be used for all messages henceforth, the Application Data protocol ensuring secure fragmentation, compression and encryption during transmissions and the Handshake protocol defining an initial agreement on keys and cryptographic algorithms used for that session.

\section{Handshake Analysis}
The TLS Handshake Protocol is responsible for the authentication and key exchange necessary to establish or resume secure sessions. When establishing a secure session, the Handshake Protocol manages the following:
\begin{itemize}
\item \emph{Cipher suite negotiation}
\item \emph{Authentication of the server and optionally, the client}. The use of public/private key pairs is the basis of this step. The exact method used for authentication is determined by the cipher suite negotiated.
\item \emph{Session key information exchange}. The client and server exchange random numbers and a special number called the Pre-Master Secret. These numbers are combined with additional data permitting client and server to create their shared secret, called the Master Secret that will be used to generate the MAC and symmetric encryption session keys.
\end{itemize}

The exchanged messages are, at a high level, the ones in Figure\ref{fig:messages}. In the following sections we will go deeper in the details of the protocol through an example.

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{tls-messages-hw6-1642557}
\centering
\caption{TLS Handshake messages}
\label{fig:messages}
\end{figure}

To obtain the packets analysed in the following sections we used Wireshark packet sniffer version 2.4.3 on macOS. For the example we opted for an online payments and money transfer systems website (\url{www.paypal.com}) and we used a Chrome browser to connect to it.
We started the packet capturing without filters, but we filtered the result view. In order to get get the packets we were interested in, we first obtained the IP address of \texttt{www.paypal.com} with the following command:
\begin{verbatim}
$> nslookup www.paypal.com
\end{verbatim}
Then we used the following display filter inside Wireshark:
\begin{verbatim}
ssl.handshake and (ip.addr== 2.21.164.221 and tcp.port == 58431)
\end{verbatim}
Notice that we selected a single port since in general connecting to a website implies opening multiple TCP connections and we decided to follow one with a flow that was interesting for our purposes.

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{wsmessages-hw6-1642557}
\centering
\caption{Wireshark output filtered on TLS handshake}
\label{fig:wsmessages}
\end{figure}

\subsection*{First message exchange}
\paragraph*{Client Hello}
The first message in the TLS Handshake is the client hello message which is sent by the client to initiate a session with the server.

In particular, as we can see in the Figure \ref{fig:clienthello}, the client communicate the highest version supported that is also the one that the client wants to use. Then a pseudorandom number is sent that will be used later for the creation of the Master secret. A unique number is used to identify a session while the other important part is the Cipher Suite. It is essentially a list of strings that represent tuples composed by a key exchange algorithm, an encryption algorithm with relative chaining method, a pseudorandom function and a MAC algorithm. These suites are ordered by the client preference. Optionally other parameters are sent including compression methods and extensions.

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{clienthello-hw6-1642557}
\centering
\caption{Client hello frame}
\label{fig:clienthello}
\end{figure}

\paragraph*{Server response}
The server responses to client with multiple messages. The Server Hello message contains the highest version supported both by the server and the client and the single strongest cipher suite that both the server and the client support. If there is no supporting cipher suite, then a handshake failure alert is created. It also contains another 32-bytes random number with the same purpose of the client's one.

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{serverhello-hw6-1642557}
\centering
\caption{Server hello}
\label{fig:serverhello}
\end{figure}

Then the servers sends the client a list of X.509 certificates to authenticate itself. The server’s certificate contains its public key. After that the client, if in the Client Hello message it specified a \texttt{status\_request} extension (that is our case in the example), to make sure that the certificate is still valid, should contact an OSCP (Online Certificate Status Protocol) server, but so save bandwidth the response is sent by the server (OSCP Stapling). This response is of course signed and dated.

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{serverresp-hw6-1642557}
\centering
\caption{Server response}
\label{fig:serverresp}
\end{figure}

The Server Key Exchange message is optional and sent when the public key present in the server’s certificate is not suitable for key exchange or if the cipher suite places a restriction requiring a temporary key. This key is used by the client to encrypt Client Key Exchange later in the process. Finally to indicate that the server is awaiting for a response from the client a Server Hello Done message is sent (Figure \ref{fig:serverresp}).

\subsection*{Second message exchange}
\paragraph*{Client response}
With this message, the premaster secret is set, either by direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret (our case). This along with the client and server random number is used to create the master secret. The client will be guaranteed of the authenticity of the server if will be able to decrypt the message using the private key and to create the master secret locally. The Change Cipher Spec message is sent by both the client and the server, after the security parameters have been agreed upon, and is a notification that henceforth the just negotiated CipherSpec and keys will be employed. Finally the Encrypted Handshake Message is a hash of all messages exchanged previously (not including current message and Hello request messages) along with a "finished" label indicating that the client has terminated his TLS negotiation of algorithms, keys and secrets. A Finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful (Figure \ref{fig:clientresp}).

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{clientresp-hw6-1642557}
\centering
\caption{Client Key Exchange, etc.}
\label{fig:clientresp}
\end{figure}

\paragraph*{Server final response}
This message is equivalent to the Client Finished message but contains a different label (“server finished”). Once the client has successfully decrypted and verified this message, the server can be considered as successfully authenticated. We notice the presence of a New Session Ticket message; this refers to an additional mechanism supported by TLS that defines a way to resume a session without requiring session-specific state at the TLS server, making possible to the server to handle a larger number of transactions. The term 'ticket' \cite{RFC5077} refers to a data structure encrypted and integrity-protected by a key known only to the server, used to rebuild session-specific state when it is received back from the client asking for a session restore. In this case an empty extension named SessionTicket was sent in the Client Hello indicating that the client supported this mechanism, so in the final message a new session ticket is granted by the server (Fig. \ref{fig:finished}).

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{finished-hw6-1642557}
\centering
\caption{From Server: Session Ticket, Change Cipher Spec, Finished}
\label{fig:finished}
\end{figure}

\paragraph*{Application dataflow}
Once the entire TLS Handshake is successfully completed and both server and client validated the entire process, the applications start to exchange application data messages.

\section{Conclusions}
So far we have discussed the message flow in a typical TLS connection analysing the traffic generated by a browser. We have used Wireshark to capture and filter the packets of interest and we analysed the most important parameters used during the Handshake phase of the protocol. This gave us a nice insight in the mechanisms at the base of TLS; an interesting future work could be the analysis of the traffic of a DTLS handshake or even DTLS-SRTP designed for respective real-time protocol.

\clearpage
\nocite{*} % Show all Bib-entries
\bibliography{hw6-1642557} 
\bibliographystyle{plain}

\end{document}